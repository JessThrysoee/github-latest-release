#!/bin/bash

# prerequisite: curl, jq, bsdtar (libarchive-tools)

set -euo pipefail


function curl() {
  local bearer_token="$1"
  local accept="$2"
  shift 2
  command curl --fail-with-body -sSL \
      ${bearer_token:+ -H "Authorization: Bearer ${bearer_token}"} \
      ${accept:+ -H "Accept: ${accept}"} \
      "$@"
}

list_download_urls() {
    local bearer_token="$1"
    local repo="$2"

    curl "$bearer_token" "" "https://api.github.com/repos/${repo}/releases/latest" \
      | jq --unbuffered -r '.assets[].browser_download_url'
}

fetch_asset_metadata() {
    local bearer_token="$1"
    local repo="$2"
    local regex="$3"

    curl "$bearer_token" "" "https://api.github.com/repos/${repo}/releases/latest" \
        | jq --unbuffered -r --arg regex "$regex" '.assets[] | select(.browser_download_url|test($regex)) | { url, name }'
}

select_single_download_url() {
    local bearer_token="$1"
    local repo="$2"
    local regex="$3"

    matches="$(curl "$bearer_token" "" "https://api.github.com/repos/${repo}/releases/latest" \
        | jq --unbuffered -r --arg regex "$regex" '.assets[].browser_download_url | select(.|test($regex))')"

    if [[ -z $matches ]]; then
        lines="0"
    else
        lines="$(wc -l <<< "$matches" | tr -d '[:blank:]')"
    fi

    if (( lines != 1 )); then
        echo "found $lines matches, refine the pattern '$regex' until exactly one match is found" >&2
        if (( lines > 0 )); then
            printf "\n%s\n" "$matches" >&2
        fi
        exit 1
    else
        printf "%s\n" "$matches"
    fi
}

fetch_release() {
    local bearer_token="$1"
    local repo="$2"
    local regex_pattern="$3"
    local output="$4"

    local asset asset_url
    asset="$(fetch_asset_metadata "$bearer_token" "$repo" "$regex_pattern")"
    asset_url="$(jq -r .url <<< "$asset")"

    if [[ -z $output ]]; then
        output="$(jq -r .name <<< "$asset")"
    fi

    curl "$bearer_token" "application/octet-stream" -o "$output" "$asset_url"
}

list_files() {
    local bearer_token="$1"
    local repo="$2"
    local regex_pattern="$3"
    local include_glob_pattern="$4"

    local asset asset_url
    asset="$(fetch_asset_metadata "$bearer_token" "$repo" "$regex_pattern")"
    asset_url="$(jq -r .url <<< "$asset")"

    curl "$bearer_token" "application/octet-stream" "$asset_url" \
        | bsdtar -t --include "$include_glob_pattern"
}

extract_files() {
    local bearer_token="$1"
    local repo="$2"
    local regex_pattern="$3"
    local include_glob_pattern="$4"
    local strip_components="$5"
    local directory="$6"

    local asset asset_url
    asset="$(fetch_asset_metadata "$bearer_token" "$repo" "$regex_pattern")"
    asset_url="$(jq -r .url <<< "$asset")"

    curl "$bearer_token" "application/octet-stream" "$asset_url" \
        | bsdtar -x --include "$include_glob_pattern" --strip-components "$strip_components" -C "$directory"
}

usage() {
    cat <<'EOF'
Usage:

  github-latest-release [-b <BEARER_TOKEN>] -r <OWNER/REPO> -l -p [REGEX]
  github-latest-release [-b <BEARER_TOKEN>] -r <OWNER/REPO> -f -p <REGEX> -o [OUTPUT]
  github-latest-release [-b <BEARER_TOKEN>] -r <OWNER/REPO> -t -p <REGEX> \
                        -i [INCLUDE_GLOB]
  github-latest-release [-b <BEARER_TOKEN>] -r <OWNER/REPO> -x -p <REGEX> \
                        -i [INCLUDE_GLOB] -s [STRIP_COMPONENTS] -c [DIRECTORY]

Options:

  -b <BEARER_TOKEN>
      Authorization token.

     Example:
       github-latest-release -b "$(gh auth token)" -r enterprise/repo -l

  -r <OWNER/REPO>
     The github repo identifier. The 'owner/repo' part of 'https://github.com/owner/repo'

  -l
     List all available download urls. Use the '-p' regex pattern to identify a single
     download url for use in the fetch commands.

     Example:
       github-latest-release -r prometheus/prometheus -l -p 'linux-amd64.tar.gz$'

  -f
     Fetch a release package. Use this if the release is a single executable or to
     download an archive.

     Options:
       -o   passthrough to curl --output

     Example:
       github-latest-release -r 'tsl0922/ttyd' -f -p 'ttyd.mips64$' -o '/tmp/ttyd'

  -t
     Fetch and list files in archive.

     Options:
      -i   passthrough to bsdtar --include

     Example:
       github-latest-release -r prometheus/prometheus -x -p 'linux-amd64.tar.gz$' \
                             -i '*/prometheus'

  -x
     Fetch and extract from an archive.

     Options:
      -i   passthrough to bsdtar --include
      -s   passthrough to bsdtar --strip-components
      -c   passthrough to bsdtar --cd

     Example:
       github-latest-release -r prometheus/prometheus -x -p 'linux-amd64.tar.gz$' \
                             -i '*/prometheus' -s 1 -c /tmp

EOF
}

main() {
    local opt
    local repo=""
    local list_url=""
    local fetch=""
    local list_files=""
    local extract=""
    local regex_pattern=""
    local include_glob_pattern="*"
    local strip_components="0"
    local directory="."
    local bearer_token=""
    local output=""

    while getopts ":r:lftxp:i:s:c:b:o:h" opt; do
        case $opt in
            r) repo="$OPTARG" ;;
            l) list_url="1" ;;
            f) fetch="1" ;;
            t) list_files="1" ;;
            x) extract="1" ;;
            p) regex_pattern="$OPTARG" ;;
            i) include_glob_pattern="$OPTARG" ;;
            s) strip_components="$OPTARG" ;;
            c) directory="$OPTARG" ;;
            b) bearer_token="$OPTARG" ;;
            o) output="$OPTARG" ;;
            h) usage; exit 0 ;;
            :) echo "Error: -${OPTARG} requires an argument" >&2 ;;
            \?) echo "Invalid option -$OPTARG" >&2 ;;
        esac
    done

    if [[ -z $repo ]]; then
        usage
        exit 1
    fi

    if [[ -n $list_url ]]; then
        if [[ -n $regex_pattern ]]; then
            select_single_download_url "$bearer_token" "$repo" "$regex_pattern"
        else
            list_download_urls "$bearer_token" "$repo"
        fi

    elif [[ -n $fetch ]]; then
        select_single_download_url "$bearer_token" "$repo" "$regex_pattern" >/dev/null
        fetch_release "$bearer_token" "$repo" "$regex_pattern" "$output"

    elif [[ -n $list_files ]]; then
        select_single_download_url "$bearer_token" "$repo" "$regex_pattern" >/dev/null
        list_files "$bearer_token" "$repo" "$regex_pattern" "$include_glob_pattern"

    elif [[ -n $extract ]]; then
        select_single_download_url "$bearer_token" "$repo" "$regex_pattern" >/dev/null
        extract_files "$bearer_token" "$repo" "$regex_pattern" "$include_glob_pattern" "$strip_components" "$directory"
    else
        usage
        exit 1
    fi
}

main "$@"

